use core::prelude::*;

pub fn zlhma(source: &Series<f32>, period: usize, period_smooth: usize) -> Series<f32> {
    source
        .smooth(Smooth::HMA, period)
        .smooth(Smooth::HMA, period_smooth)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_zlhma() {
        let source = Series::from([
            7.1135, 7.088, 7.112, 7.1205, 7.1195, 7.136, 7.1405, 7.112, 7.1095, 7.1220, 7.1310,
            7.1550, 7.1480, 7.1435, 7.1405, 7.1440, 7.1495, 7.1515, 7.1415, 7.1445, 7.1525, 7.1440,
            7.1370, 7.1305, 7.1375, 7.1250, 7.1190, 7.1135, 7.1280, 7.1220, 7.1230, 7.1225, 7.1180,
            7.1250, 7.1230, 7.1130, 7.1210, 7.13, 7.134, 7.132, 7.116, 7.1235, 7.1645, 7.1565,
            7.1560,
        ]);
        let period = 3;
        let period_smooth = 2;
        let expected = vec![
            7.1135, 7.0681653, 7.133167, 7.1317506, 7.117639, 7.1519723, 7.1459727, 7.0828333,
            7.1051674, 7.135945, 7.1408334, 7.178806, 7.141832, 7.137277, 7.1376395, 7.1475835,
            7.1553617, 7.1536107, 7.131306, 7.146833, 7.1612234, 7.1357775, 7.129084, 7.124083,
            7.144527, 7.11325, 7.111916, 7.1083617, 7.1425276, 7.1171117, 7.1228623, 7.122388,
            7.113417, 7.131778, 7.1216393, 7.1024995, 7.128556, 7.140001, 7.138055, 7.129722,
            7.099668, 7.1302214, 7.2068057, 7.1503606, 7.1527786,
        ];

        let result: Vec<f32> = zlhma(&source, period, period_smooth).into();

        assert_eq!(result, expected);
    }
}
